tutorial feedback
=================

generally
---------

- introduction text prior first code cell.
- present more output of created objects.
- %cd -q .. should be gone, when this is final, as it stores outputs (figures etc.) next to the source code.
- more comments in source code to link to text descriptions.
- link mentioned classes in notebooks to quickly lookup their documentation.
- ISOBaseGroove.to_profile wrap with pint to set default unit to "mm"?
- use PEP8 in notebooks as well
- cross-link notebooks (via markdown refs) where appropriate.
- raise specialized exceptions, not plain base exceptions. This makes error handling easier (and understandable).


possible API/impl improvements
-----------------------------
- think of having default units for scalar inputs (pint-wrapping-function), e.g. "mm" for lengths and "degree" for angles.
  This avoids the need for the users to wrap everything themselves.
- pandas seems to be used only for TimeDeltaIndex and Timestamp, 
  shouldn't we consider to use stdlib features for this purpose and get rid of the pandas dependency?
  I guess you've chosen these types for a good reason. Eventually it might be worth considering extracting these two classes into weldx.
- _write_read_buffer is used publicly, but is a private function (I guess this can be public).

- prefer tuples of lists (a bit faster, e.g. 7ns vs 50ns), but is negligible.


welding_example_01_basics
-------------------------

* get_groove(), too many arguments! 
  why not have get_groove_V, get_groove_u functions only containing relevant arguments?
  It seems overwhelming for users, to dig through all parameters to determine which are needed.
  When we choose to have separate functions, we get required/optional parameters for free due to Python semantics.

  Interpretation of the same argument depend on groove type, that's confusing at least.
  Implementation-wise it is very elegant, but not so user-friendly (parameter checking on runtime, mapping of names/types etc.).

* CoordinateSystemManager.add_cs() can be called multiple times with the same cs names. Is this intended?
  # comment from src:
            #  discuss: update and add functionality should be separated
            #  why?   : to prevent errors. Misspelling of the system name might cause
            #           unwanted updates or unwanted additions. Separate function can
            #           catch that by knowing about the users intention.
   I totally agree, that this should be separate methods!
   
 
 
groove_types_01
---------------

- add reference to iso-standard in text
- plotting of all available groove types calls private method _create_test_grooves. This can be public too.
- FFGroove plot is not a closed shape, e.g. left upper corner of big workpiece is not fully connected.



measurement_example
-------------------

- "import weldx.measurement as msm" is a strange abbreviation :)
- "import weldx.transformations as tf", tf is usually used to abbrivate tensor flow, so we should consider something else.
- time type is now numpy datetime, what about using one time type all over the place?
- weldx.asdf.tags.weldx.core.mathematical_expression import MathematicalExpression, why is a tag used as user-api?
- The user has to create far too many objects, we should provide a factory.

welding_example_02_weaving
--------------------------

- line 76ff:
  # define the weld seam length in mm
  seam_length = 150 # why is the unit implicit here, although the ctor of LinearHorizontalTraceSegment is not pint wrapped?
  # create a linear trace segment a the complete weld seam trace
  trace_segment = geo.LinearHorizontalTraceSegment(seam_length)
- 


GMAW_process
------------
Describe whats going on. What things get defined etc.
This seems like a practical example for the user, so it would be more insightful to explain how to attach measurements
to the process (or at least link to the notebook explaining it).

Showing the output of the serialization is somehow cool, but whats the benefit in a tutorial? Would users ever look at
this? Writing it to a proper file, so people get an idea, what will be lying around on their filesystem seems more like a
real world application.


transformations_01_coordinate_systems
-------------------------------------

- Language is technical (users would not know what the difference between a constructor and a factory method is). We can
  just omit that, and demonstrate the different behavior.

- Users are asked to "install the corresponding extensions" during the tutorial. This should be done by us, so people can
 focus on the actual task of understanding the tutorial.

- We shouldn't put lots of code into the tutorials, if necessary we can hide it in a utility module alongside the notebooks.
  This gets imported on top and used later, so it does not confuse the users later on.
  Should be done, once the layout/content is final.

- Legends (ref, parent, child etc.) in slide plots (really cool btw) hide the actual 3d grid, so one cannot see whats going on exactly.
  Legend has to be placed outside of the grid. https://stackoverflow.com/questions/4700614/how-to-put-the-legend-out-of-the-plot
  (I think this only happened when using widgets).

- Practical question, is the user really asked to define lcs for the movements of the torch/robot, or can there be a way to
  extract these information and convert it to weldx objects? This would greatly improve the acceptance of weldx, since
  doing it manually seems tedious and error prone.

- Ask users to learn xarray seems a bit overwhelming. We can be lucky if the know how to use NumPy.
  Better link to to documentation of xarray wrapper funcs


transformations_02_coordinate_system_manager
--------------------------------------------

- Do not Hint about hashable names for the CSM name, but enforce strings. This makes everybody's life easier.

- CSM constructor has private arguments. This should be avoided.

- do not use assert in a tutorial, but show the actual result of the comparison (csm.transform_data(specimen_geometry_in_specimen, "specimen", "root") == specimen_geometry_in_root)

- With the manager is actually easy to create LCS, so why not introduce it earlier skipping some of the functionalities
  of LCS in favour of explaining the managers features.

- relabel() why a mapping, if two arguments (src, dst) can be used? Ensure the type is hashable? Just allow only str


geometry_01_profiles
--------------------

- Defining custom types is a nice feature, but too complicated for the aspect of a tutorial. Eventually split the
  programming example to an "expert"-level tutorial.
